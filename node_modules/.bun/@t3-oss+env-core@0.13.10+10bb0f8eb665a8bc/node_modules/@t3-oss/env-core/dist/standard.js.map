{"version":3,"file":"standard.js","names":["result: Record<string, unknown>","issues: StandardSchemaV1.Issue[]"],"sources":["../src/standard.ts"],"sourcesContent":["/** The Standard Schema interface. */\nexport interface StandardSchemaV1<Input = unknown, Output = Input> {\n  /** The Standard Schema properties. */\n  readonly \"~standard\": StandardSchemaV1.Props<Input, Output>;\n}\n\nexport declare namespace StandardSchemaV1 {\n  /** The Standard Schema properties interface. */\n  export interface Props<Input = unknown, Output = Input> {\n    /** The version number of the standard. */\n    readonly version: 1;\n    /** The vendor name of the schema library. */\n    readonly vendor: string;\n    /** Validates unknown input values. */\n    readonly validate: (value: unknown) => Result<Output> | Promise<Result<Output>>;\n    /** Inferred types associated with the schema. */\n    readonly types?: Types<Input, Output> | undefined;\n  }\n\n  /** The result interface of the validate function. */\n  export type Result<Output> = SuccessResult<Output> | FailureResult;\n\n  /** The result interface if validation succeeds. */\n  export interface SuccessResult<Output> {\n    /** The typed output value. */\n    readonly value: Output;\n    /** The non-existent issues. */\n    readonly issues?: undefined;\n  }\n\n  /** The result interface if validation fails. */\n  export interface FailureResult {\n    /** The issues of failed validation. */\n    readonly issues: ReadonlyArray<Issue>;\n  }\n\n  /** The issue interface of the failure output. */\n  export interface Issue {\n    /** The error message of the issue. */\n    readonly message: string;\n    /** The path of the issue, if any. */\n    readonly path?: ReadonlyArray<PropertyKey | PathSegment> | undefined;\n  }\n\n  /** The path segment interface of the issue. */\n  export interface PathSegment {\n    /** The key representing a path segment. */\n    readonly key: PropertyKey;\n  }\n\n  /** The Standard Schema types interface. */\n  export interface Types<Input = unknown, Output = Input> {\n    /** The input type of the schema. */\n    readonly input: Input;\n    /** The output type of the schema. */\n    readonly output: Output;\n  }\n\n  /** Infers the input type of a Standard Schema. */\n  export type InferInput<Schema extends StandardSchemaV1> = NonNullable<\n    Schema[\"~standard\"][\"types\"]\n  >[\"input\"];\n\n  /** Infers the output type of a Standard Schema. */\n  export type InferOutput<Schema extends StandardSchemaV1> = NonNullable<\n    Schema[\"~standard\"][\"types\"]\n  >[\"output\"];\n}\n\nexport type StandardSchemaDictionary<\n  Input = Record<string, unknown>,\n  Output extends Record<keyof Input, unknown> = Input,\n> = {\n  [K in keyof Input]-?: StandardSchemaV1<Input[K], Output[K]>;\n};\n\nexport namespace StandardSchemaDictionary {\n  export type InferInput<T extends StandardSchemaDictionary> = {\n    [K in keyof T]: StandardSchemaV1.InferInput<T[K]>;\n  };\n  export type InferOutput<T extends StandardSchemaDictionary> = {\n    [K in keyof T]: StandardSchemaV1.InferOutput<T[K]>;\n  };\n}\n\nexport function ensureSynchronous<T>(value: T | Promise<T>, message: string): asserts value is T {\n  if (value instanceof Promise) {\n    throw new Error(message);\n  }\n}\n\nexport function parseWithDictionary<TDict extends StandardSchemaDictionary>(\n  dictionary: TDict,\n  value: Record<string, unknown>,\n): StandardSchemaV1.Result<StandardSchemaDictionary.InferOutput<TDict>> {\n  const result: Record<string, unknown> = {};\n  const issues: StandardSchemaV1.Issue[] = [];\n  for (const key in dictionary) {\n    const propResult = dictionary[key][\"~standard\"].validate(value[key]);\n\n    ensureSynchronous(propResult, `Validation must be synchronous, but ${key} returned a Promise.`);\n\n    if (propResult.issues) {\n      issues.push(\n        ...propResult.issues.map((issue) => ({\n          ...issue,\n          message: issue.message, // https://github.com/t3-oss/t3-env/pull/346\n          path: [key, ...(issue.path ?? [])],\n        })),\n      );\n      continue;\n    }\n    result[key] = propResult.value;\n  }\n  if (issues.length) {\n    return { issues };\n  }\n  return { value: result as never };\n}\n"],"mappings":";AAqFA,SAAgB,kBAAqB,OAAuB,SAAqC;AAC/F,KAAI,iBAAiB,QACnB,OAAM,IAAI,MAAM,QAAQ;;AAI5B,SAAgB,oBACd,YACA,OACsE;CACtE,MAAMA,SAAkC,EAAE;CAC1C,MAAMC,SAAmC,EAAE;AAC3C,MAAK,MAAM,OAAO,YAAY;EAC5B,MAAM,aAAa,WAAW,KAAK,aAAa,SAAS,MAAM,KAAK;AAEpE,oBAAkB,YAAY,uCAAuC,IAAI,sBAAsB;AAE/F,MAAI,WAAW,QAAQ;AACrB,UAAO,KACL,GAAG,WAAW,OAAO,KAAK,WAAW;IACnC,GAAG;IACH,SAAS,MAAM;IACf,MAAM,CAAC,KAAK,GAAI,MAAM,QAAQ,EAAE,CAAE;IACnC,EAAE,CACJ;AACD;;AAEF,SAAO,OAAO,WAAW;;AAE3B,KAAI,OAAO,OACT,QAAO,EAAE,QAAQ;AAEnB,QAAO,EAAE,OAAO,QAAiB"}